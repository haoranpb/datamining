## 背景

我们不能完全的依据一个客户的身材来对衣服的尺码进行推荐，因为每一个顾客对每一件衣服的感觉是不同的，比如两个身材完全相同的顾客张三和李四，同时购买了一款 中等 尺寸的衣服，张三可能觉得衣服完全合适，但是李四却可能觉得衣服有些偏小了。即用户偏差

同样的是，我们也不能完全根据一件衣服的尺码来把它推荐给顾客，因为同一尺码而不同款式的衣服对于顾客来说可能是完全不同的，比如说，同是中等尺码的衣服，第一款的衣服可能是正合适，但是第二款可能肩膀却比较瘦。即商品偏差

## 数据预处理

### 打乱数据

观察 `renttherunway` 与 `modcloth` 的两组数据，我们可以发现所有的数据较为集中，尤其是标签为 `fit` 的数据占了整个数据集的大多数。为了将数据集彻底打乱，防止过于集中的数据集干扰模型的收敛情况，同时避免模型在训练过程中出现对某一类数据出现过拟合的现象。

比如，如果数据集一开始输入的全是A类数据，那么模型就会在A类数据上过拟合。当A类数据输入完毕后，又开始输入B类数据，此时模型又开始尽力逼近B类数据，再次产生过拟合。

有趣的是，在尝试打乱数据的过程中，我们发现了如果直接使用 `random.shuffle` 函数尝试打乱数据的话，那么每次进入程序时，数据的打乱顺序都是一样的。为了让程序正真的随机，需要每次使用 `randm` 的函数前，调用 `random.seed` 生成新的随机种子。

### 筛选数据内容

在论文提供的两个数据文件中，我们发现了很多没有在论文中用到的数据，为了减少程序运行过程中不必要的内存占用，以及加快程序运行速度，我们对原数据文件进行了一次数据筛选过程。只留下真正在程序中会用到的数据，而删除剩余不必要的数据。

### 训练集与测试集划分

为了能够验证我们模型最后的训练结果，我们决定将数据分按 9：1 的比例分为了训练集和测试集。我们使用训练集对数据进行训练，而使用测试集来对训练好的模型进行测试。使用 AUC 参数来检测一个模型的好坏。

### 初始化辅助变量

#### sizes

一个字典，记录所有衣服的 `size` 的个数

键：一件衣服的 `size`

值：一个 `size` 出现的次数，一个整数

#### cloth_data

一个字典，`cloth_id | size` 对应**一行或多行**数据

键：`cloth_id|size`

值：一款特定大小的衣服所对应的所有数据，一个列表

#### cloth_order

一个字典，`cloth_id | size` 对应数据输入顺序

键：`cloth_id|size`

值：一款特定大小的衣服第一次在数据中出现的编号，一个整数

####parent_cloth_order

一个字典，为每一款衣服进行编号。每件有具体大小的衣服都是该款式衣服的子衣服；反过来说，每款衣服都是有具体大小的该款衣服的父衣服。为了方便，按顺序对每款衣服进行编号。

键：`cloth_id`

值：一款衣服第一次在数据中出现的编号，一个整数

#### customer_data

一个字典，`user_id` 对应**一行或多行**数据

键：`cloth_id`

值：一款衣服第一次在数据中出现的编号，一个整数

#### cloth_size

一个字典，记录每款衣服的全部尺寸，并排序

键：`cloth_id`

值：该款衣服的所有的 `size`，一个列表（集合）

#### cloth_larger

一个字典，用作一个类似于链表的存储结构

键：一款特定大小的衣服第一次在数据中出现的编号，一个整数

值：同款大一号衣服第一次在数据中出现的编号，一个整数

#### cloth_smaller: 

一个字典，用作一个类似于链表的存储结构

键：一款特定大小的衣服第一次在数据中出现的编号，一个整数

值：同款小一号衣服第一次在数据中出现的编号，一个整数



## 特征提取

筛选原型



